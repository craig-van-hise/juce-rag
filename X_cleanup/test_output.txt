No sentence-transformers model found with name google/embedding-gemma-300m. Creating a new one with mean pooling.
..F...
======================================================================
FAIL: test_A3_content_extraction (__main__.TestJuceRAG.test_A3_content_extraction)
A.3 Content Extraction: Scrape juce::AudioBuffer
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/vv2024/Documents/AI Projects/JUCE Docs Data/test_rag.py", line 53, in test_A3_content_extraction
    self.assertIn("Manage a buffer of audio samples", doc.raw_text, "Content extraction failed for AudioBuffer")
    ~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AssertionError: 'Manage a buffer of audio samples' not found in "Detailed Description\ntemplate<typename Type>\nclass juce::AudioBuffer< Type >\nA multi-channel buffer containing floating point audio samples.\nThe documentation for this class was generated from the following file:\njuce_audio_basics/buffers/\njuce_AudioSampleBuffer.h\nPublic Types\nusing\nSampleType\n= Type\nThis allows templated code that takes an\nAudioBuffer\nto access its sample type.\nPublic Member Functions\nAudioBuffer\n() noexcept\nCreates an empty buffer with 0 channels and 0 length.\nAudioBuffer\n(int numChannelsToAllocate, int numSamplesToAllocate)\nCreates a buffer with a specified number of channels and samples.\nAudioBuffer\n(Type *const *dataToReferTo, int numChannelsToUse, int numSamples)\nCreates a buffer using a pre-allocated block of memory.\nAudioBuffer\n(Type *const *dataToReferTo, int numChannelsToUse, int startSample, int numSamples)\nCreates a buffer using a pre-allocated block of memory.\nAudioBuffer\n(const AudioBuffer &other)\nCopies another buffer.\nAudioBuffer\n&\noperator=\n(const\nAudioBuffer\n&other)\nCopies another buffer onto this one.\n~AudioBuffer\n()=default\nDestructor.\nAudioBuffer\n(AudioBuffer &&other) noexcept\nMove constructor.\nAudioBuffer\n&\noperator=\n(\nAudioBuffer\n&&other) noexcept\nMove assignment.\nint\ngetNumChannels\n() const noexcept\nReturns the number of channels of audio data that this buffer contains.\nint\ngetNumSamples\n() const noexcept\nReturns the number of samples allocated in each of the buffer's channels.\nconst Type *\ngetReadPointer\n(int channelNumber) const noexcept\nReturns a pointer to an array of read-only samples in one of the buffer's channels.\nconst Type *\ngetReadPointer\n(int channelNumber, int sampleIndex) const noexcept\nReturns a pointer to an array of read-only samples in one of the buffer's channels.\nType *\ngetWritePointer\n(int channelNumber) noexcept\nReturns a writeable pointer to one of the buffer's channels.\nType *\ngetWritePointer\n(int channelNumber, int sampleIndex) noexcept\nReturns a writeable pointer to one of the buffer's channels.\nconst Type *const *\ngetArrayOfReadPointers\n() const noexcept\nReturns an array of pointers to the channels in the buffer.\nType *const *\ngetArrayOfWritePointers\n() noexcept\nReturns an array of pointers to the channels in the buffer.\nvoid\nsetSize\n(int newNumChannels, int newNumSamples, bool keepExistingContent=false, bool clearExtraSpace=false, bool avoidReallocating=false)\nChanges the buffer's size or number of channels.\nvoid\nsetDataToReferTo\n(Type *const *dataToReferTo, int newNumChannels, int newStartSample, int newNumSamples)\nMakes this buffer point to a pre-allocated set of channel data arrays.\nvoid\nsetDataToReferTo\n(Type *const *dataToReferTo, int newNumChannels, int newNumSamples)\nMakes this buffer point to a pre-allocated set of channel data arrays.\ntemplate<typename OtherType>\nvoid\nmakeCopyOf\n(const\nAudioBuffer\n< OtherType > &other, bool avoidReallocating=false)\nResizes this buffer to match the given one, and copies all of its content across.\nvoid\nclear\n() noexcept\nClears all the samples in all channels and marks the buffer as cleared.\nvoid\nclear\n(int startSample, int numSamples) noexcept\nClears a specified region of all the channels.\nvoid\nclear\n(int channel, int startSample, int numSamples) noexcept\nClears a specified region of just one channel.\nbool\nhasBeenCleared\n() const noexcept\nReturns true if the buffer has been entirely cleared.\nvoid\nsetNotClear\n() noexcept\nForces the internal cleared flag of the buffer to false.\nType\ngetSample\n(int channel, int sampleIndex) const noexcept\nReturns a sample from the buffer.\nvoid\nsetSample\n(int destChannel, int destSample, Type newValue) noexcept\nSets a sample in the buffer.\nvoid\naddSample\n(int destChannel, int destSample, Type valueToAdd) noexcept\nAdds a value to a sample in the buffer.\nvoid\napplyGain\n(int channel, int startSample, int numSamples, Type gain) noexcept\nApplies a gain multiple to a region of one channel.\nvoid\napplyGain\n(int startSample, int numSamples, Type gain) noexcept\nApplies a gain multiple to a region of all the channels.\nvoid\napplyGain\n(Type gain) noexcept\nApplies a gain multiple to all the audio data.\nvoid\napplyGainRamp\n(int channel, int startSample, int numSamples, Type startGain, Type endGain) noexcept\nApplies a range of gains to a region of a channel.\nvoid\napplyGainRamp\n(int startSample, int numSamples, Type startGain, Type endGain) noexcept\nApplies a range of gains to a region of all channels.\nvoid\naddFrom\n(int destChannel, int destStartSample, const\nAudioBuffer\n&source, int sourceChannel, int sourceStartSample, int numSamples, Type gainToApplyToSource=Type(1)) noexcept\nAdds samples from another buffer to this one.\nvoid\naddFrom\n(int destChannel, int destStartSample, const Type *source, int numSamples, Type gainToApplyToSource=Type(1)) noexcept\nAdds samples from an array of floats to one of the channels.\nvoid\naddFromWithRamp\n(int destChannel, int destStartSample, const Type *source, int numSamples, Type startGain, Type endGain) noexcept\nAdds samples from an array of floats, applying a gain ramp to them.\nvoid\ncopyFrom\n(int destChannel, int destStartSample, const\nAudioBuffer\n&source, int sourceChannel, int sourceStartSample, int numSamples) noexcept\nCopies samples from another buffer to this one.\nvoid\ncopyFrom\n(int destChannel, int destStartSample, const Type *source, int numSamples) noexcept\nCopies samples from an array of floats into one of the channels.\nvoid\ncopyFrom\n(int destChannel, int destStartSample, const Type *source, int numSamples, Type gain) noexcept\nCopies samples from an array of floats into one of the channels, applying a gain to it.\nvoid\ncopyFromWithRamp\n(int destChannel, int destStartSample, const Type *source, int numSamples, Type startGain, Type endGain) noexcept\nCopies samples from an array of floats into one of the channels, applying a gain ramp.\nRange\n< Type >\nfindMinMax\n(int channel, int startSample, int numSamples) const noexcept\nReturns a\nRange\nindicating the lowest and highest sample values in a given section.\nType\ngetMagnitude\n(int channel, int startSample, int numSamples) const noexcept\nFinds the highest absolute sample value within a region of a channel.\nType\ngetMagnitude\n(int startSample, int numSamples) const noexcept\nFinds the highest absolute sample value within a region on all channels.\nType\ngetRMSLevel\n(int channel, int startSample, int numSamples) const noexcept\nReturns the root mean squared level for a region of a channel.\nvoid\nreverse\n(int channel, int startSample, int numSamples) const noexcept\nReverses a part of a channel.\nvoid\nreverse\n(int startSample, int numSamples) const noexcept\nReverses a part of the buffer.\nMember Typedef Documentation\n◆\nSampleType\ntemplate<typename Type>\nusing\njuce::AudioBuffer\n< Type >::SampleType = Type\nThis allows templated code that takes an\nAudioBuffer\nto access its sample type.\nConstructors and Destructors\n◆\nAudioBuffer()\n[1/6]\ntemplate<typename Type>\njuce::AudioBuffer\n< Type >::AudioBuffer\n(\n)\ninline\nnoexcept\nCreates an empty buffer with 0 channels and 0 length.\n◆\nAudioBuffer()\n[2/6]\ntemplate<typename Type>\njuce::AudioBuffer\n< Type >::AudioBuffer\n(\nint\nnumChannelsToAllocate\n,\nint\nnumSamplesToAllocate\n)\ninline\nCreates a buffer with a specified number of channels and samples.\nThe contents of the buffer will initially be undefined, so use\nclear()\nto set all the samples to zero.\nThe buffer will allocate its memory internally, and this will be released when the buffer is deleted. If the memory can't be allocated, this will throw a std::bad_alloc exception.\n◆\nAudioBuffer()\n[3/6]\ntemplate<typename Type>\njuce::AudioBuffer\n< Type >::AudioBuffer\n(\nType *const *\ndataToReferTo\n,\nint\nnumChannelsToUse\n,\nint\nnumSamples\n)\ninline\nCreates a buffer using a pre-allocated block of memory.\nNote that if the buffer is resized or its number of channels is changed, it will re-allocate memory internally and copy the existing data to this new area, so it will then stop directly addressing this memory.\nParameters\ndataToReferTo\na pre-allocated array containing pointers to the data for each channel that should be used by this buffer. The buffer will only refer to this memory, it won't try to delete it when the buffer is deleted or resized.\nnumChannelsToUse\nthe number of channels to use - this must correspond to the number of elements in the array passed in\nnumSamples\nthe number of samples to use - this must correspond to the size of the arrays passed in\n◆\nAudioBuffer()\n[4/6]\ntemplate<typename Type>\njuce::AudioBuffer\n< Type >::AudioBuffer\n(\nType *const *\ndataToReferTo\n,\nint\nnumChannelsToUse\n,\nint\nstartSample\n,\nint\nnumSamples\n)\ninline\nCreates a buffer using a pre-allocated block of memory.\nNote that if the buffer is resized or its number of channels is changed, it will re-allocate memory internally and copy the existing data to this new area, so it will then stop directly addressing this memory.\nParameters\ndataToReferTo\na pre-allocated array containing pointers to the data for each channel that should be used by this buffer. The buffer will only refer to this memory, it won't try to delete it when the buffer is deleted or resized.\nnumChannelsToUse\nthe number of channels to use - this must correspond to the number of elements in the array passed in\nstartSample\nthe offset within the arrays at which the data begins\nnumSamples\nthe number of samples to use - this must correspond to the size of the arrays passed in\n◆\nAudioBuffer()\n[5/6]\ntemplate<typename Type>\njuce::AudioBuffer\n< Type >::AudioBuffer\n(\nconst AudioBuffer< Type > &\nother\n)\ninline\nCopies another buffer.\nThis buffer will make its own copy of the other's data, unless the buffer was created using an external data buffer, in which case both buffers will just point to the same shared block of data.\n◆\n~AudioBuffer()\ntemplate<typename Type>\njuce::AudioBuffer\n< Type >::~\nAudioBuffer\n(\n)\ndefault\nDestructor.\nThis will free any memory allocated by the buffer.\n◆\nAudioBuffer()\n[6/6]\ntemplate<typename Type>\njuce::AudioBuffer\n< Type >::AudioBuffer\n(\nAudioBuffer< Type > &&\nother\n)\ninline\nnoexcept\nMove constructor.\nMember Functions\n◆\noperator=()\n[1/2]\ntemplate<typename Type>\nAudioBuffer\n&\njuce::AudioBuffer\n< Type >::operator=\n(\nconst\nAudioBuffer\n< Type > &\nother\n)\ninline\nCopies another buffer onto this one.\nThis buffer's size will be changed to that of the other buffer.\n◆\noperator=()\n[2/2]\ntemplate<typename Type>\nAudioBuffer\n&\njuce::AudioBuffer\n< Type >::operator=\n(\nAudioBuffer\n< Type > &&\nother\n)\ninline\nnoexcept\nMove assignment.\n◆\ngetNumChannels()\ntemplate<typename Type>\nint\njuce::AudioBuffer\n< Type >::getNumChannels\n(\n)\nconst\ninline\nnoexcept\nReturns the number of channels of audio data that this buffer contains.\nSee also\ngetNumSamples\n,\ngetReadPointer\n,\ngetWritePointer\nReferenced by\njuce::ADSR::applyEnvelopeToBuffer()\n,\njuce::AudioBuffer< float >::makeCopyOf()\n,\njuce::AudioBuffer< float >::operator=()\n, and\njuce::operator==()\n.\n◆\ngetNumSamples()\ntemplate<typename Type>\nint\njuce::AudioBuffer\n< Type >::getNumSamples\n(\n)\nconst\ninline\nnoexcept\nReturns the number of samples allocated in each of the buffer's channels.\nSee also\ngetNumChannels\n,\ngetReadPointer\n,\ngetWritePointer\nReferenced by\njuce::ADSR::applyEnvelopeToBuffer()\n,\njuce::AudioProcessor::getBusBuffer()\n,\njuce::AudioBuffer< float >::makeCopyOf()\n, and\njuce::AudioBuffer< float >::operator=()\n.\n◆\ngetReadPointer()\n[1/2]\ntemplate<typename Type>\nconst Type *\njuce::AudioBuffer\n< Type >::getReadPointer\n(\nint\nchannelNumber\n)\nconst\ninline\nnoexcept\nReturns a pointer to an array of read-only samples in one of the buffer's channels.\nFor speed, this doesn't check whether the channel number is out of range, so be careful when using it!\nIf you need to write to the data, do NOT call this method and const_cast the result! Instead, you must call getWritePointer so that the buffer knows you're planning on modifying the data.\nReferenced by\njuce::AudioBuffer< float >::makeCopyOf()\n.\n◆\ngetReadPointer()\n[2/2]\ntemplate<typename Type>\nconst Type *\njuce::AudioBuffer\n< Type >::getReadPointer\n(\nint\nchannelNumber\n,\nint\nsampleIndex\n) const\ninline\nnoexcept\nReturns a pointer to an array of read-only samples in one of the buffer's channels.\nFor speed, this doesn't check whether the channel number or index are out of range, so be careful when using it!\nIf you need to write to the data, do NOT call this method and const_cast the result! Instead, you must call getWritePointer so that the buffer knows you're planning on modifying the data.\n◆\ngetWritePointer()\n[1/2]\ntemplate<typename Type>\nType *\njuce::AudioBuffer\n< Type >::getWritePointer\n(\nint\nchannelNumber\n)\ninline\nnoexcept\nReturns a writeable pointer to one of the buffer's channels.\nFor speed, this doesn't check whether the channel number is out of range, so be careful when using it!\nNote that if you're not planning on writing to the data, you should always use getReadPointer instead.\nThis will mark the buffer as not cleared and the hasBeenCleared method will return false after this call. If you retain this write pointer and write some data to the buffer after calling its clear method, subsequent clear calls will do nothing. To avoid this either call this method each time you need to write data, or use the setNotClear method to force the internal cleared flag to false.\nSee also\nsetNotClear\nReferenced by\njuce::ADSR::applyEnvelopeToBuffer()\n.\n◆\ngetWritePointer()\n[2/2]\ntemplate<typename Type>\nType *\njuce::AudioBuffer\n< Type >::getWritePointer\n(\nint\nchannelNumber\n,\nint\nsampleIndex\n)\ninline\nnoexcept\nReturns a writeable pointer to one of the buffer's channels.\nFor speed, this doesn't check whether the channel number or index are out of range, so be careful when using it!\nNote that if you're not planning on writing to the data, you should use getReadPointer instead.\nThis will mark the buffer as not cleared and the hasBeenCleared method will return false after this call. If you retain this write pointer and write some data to the buffer after calling its clear method, subsequent clear calls will do nothing. To avoid this either call this method each time you need to write data, or use the setNotClear method to force the internal cleared flag to false.\nSee also\nsetNotClear\n◆\ngetArrayOfReadPointers()\ntemplate<typename Type>\nconst Type *const  *\njuce::AudioBuffer\n< Type >::getArrayOfReadPointers\n(\n)\nconst\ninline\nnoexcept\nReturns an array of pointers to the channels in the buffer.\nDon't modify any of the pointers that are returned, and bear in mind that these will become invalid if the buffer is resized.\n◆\ngetArrayOfWritePointers()\ntemplate<typename Type>\nType *const  *\njuce::AudioBuffer\n< Type >::getArrayOfWritePointers\n(\n)\ninline\nnoexcept\nReturns an array of pointers to the channels in the buffer.\nDon't modify any of the pointers that are returned, and bear in mind that these will become invalid if the buffer is resized.\nThis will mark the buffer as not cleared and the hasBeenCleared method will return false after this call. If you retain this write pointer and write some data to the buffer after calling its clear method, subsequent clear calls will do nothing. To avoid this either call this method each time you need to write data, or use the setNotClear method to force the internal cleared flag to false.\nSee also\nsetNotClear\nReferenced by\njuce::AudioProcessor::getBusBuffer()\n.\n◆\nsetSize()\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::setSize\n(\nint\nnewNumChannels\n,\nint\nnewNumSamples\n,\nbool\nkeepExistingContent\n=\nfalse\n,\nbool\nclearExtraSpace\n=\nfalse\n,\nbool\navoidReallocating\n=\nfalse\n)\ninline\nChanges the buffer's size or number of channels.\nThis can expand or contract the buffer's length, and add or remove channels.\nNote that if keepExistingContent and avoidReallocating are both true, then it will only avoid reallocating if neither the channel count or length in samples increase.\nIf the required memory can't be allocated, this will throw a std::bad_alloc exception.\nParameters\nnewNumChannels\nthe new number of channels.\nnewNumSamples\nthe new number of samples.\nkeepExistingContent\nif this is true, it will try to preserve as much of the old data as it can in the new buffer.\nclearExtraSpace\nif this is true, then any extra channels or space that is allocated will also be cleared. If false, then this space is left uninitialised.\navoidReallocating\nif this is true, then changing the buffer's size won't reduce the amount of memory that is currently allocated (but it will still increase it if the new size is bigger than the amount it currently has). If this is false, then a new allocation will be done so that the buffer uses the minimum amount of memory that it needs.\nReferenced by\njuce::AudioBuffer< float >::makeCopyOf()\n, and\njuce::AudioBuffer< float >::operator=()\n.\n◆\nsetDataToReferTo()\n[1/2]\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::setDataToReferTo\n(\nType *const *\ndataToReferTo\n,\nint\nnewNumChannels\n,\nint\nnewStartSample\n,\nint\nnewNumSamples\n)\ninline\nMakes this buffer point to a pre-allocated set of channel data arrays.\nThere's also a constructor that lets you specify arrays like this, but this lets you change the channels dynamically.\nNote that if the buffer is resized or its number of channels is changed, it will re-allocate memory internally and copy the existing data to this new area, so it will then stop directly addressing this memory.\nThe hasBeenCleared method will return false after this call.\nParameters\ndataToReferTo\na pre-allocated array containing pointers to the data for each channel that should be used by this buffer. The buffer will only refer to this memory, it won't try to delete it when the buffer is deleted or resized.\nnewNumChannels\nthe number of channels to use - this must correspond to the number of elements in the array passed in\nnewStartSample\nthe offset within the arrays at which the data begins\nnewNumSamples\nthe number of samples to use - this must correspond to the size of the arrays passed in\nReferenced by\njuce::AudioBuffer< float >::setDataToReferTo()\n.\n◆\nsetDataToReferTo()\n[2/2]\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::setDataToReferTo\n(\nType *const *\ndataToReferTo\n,\nint\nnewNumChannels\n,\nint\nnewNumSamples\n)\ninline\nMakes this buffer point to a pre-allocated set of channel data arrays.\nThere's also a constructor that lets you specify arrays like this, but this lets you change the channels dynamically.\nNote that if the buffer is resized or its number of channels is changed, it will re-allocate memory internally and copy the existing data to this new area, so it will then stop directly addressing this memory.\nThe hasBeenCleared method will return false after this call.\nParameters\ndataToReferTo\na pre-allocated array containing pointers to the data for each channel that should be used by this buffer. The buffer will only refer to this memory, it won't try to delete it when the buffer is deleted or resized.\nnewNumChannels\nthe number of channels to use - this must correspond to the number of elements in the array passed in\nnewNumSamples\nthe number of samples to use - this must correspond to the size of the arrays passed in\n◆\nmakeCopyOf()\ntemplate<typename Type>\ntemplate<typename OtherType>\nvoid\njuce::AudioBuffer\n< Type >::makeCopyOf\n(\nconst\nAudioBuffer\n< OtherType > &\nother\n,\nbool\navoidReallocating\n=\nfalse\n)\ninline\nResizes this buffer to match the given one, and copies all of its content across.\nThe source buffer can contain a different floating point type, so this can be used to convert between 32 and 64 bit float buffer types.\nThe hasBeenCleared method will return false after this call if the other buffer contains data.\n◆\nclear()\n[1/3]\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::clear\n(\n)\ninline\nnoexcept\nClears all the samples in all channels and marks the buffer as cleared.\nThis method will do nothing if the buffer has been marked as cleared (i.e. the hasBeenCleared method returns true.)\nSee also\nhasBeenCleared\n,\nsetNotClear\nReferenced by\njuce::ADSR::applyEnvelopeToBuffer()\n,\njuce::AudioBuffer< float >::AudioBuffer()\n,\njuce::AudioBuffer< float >::makeCopyOf()\n, and\njuce::AudioBuffer< float >::operator=()\n.\n◆\nclear()\n[2/3]\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::clear\n(\nint\nstartSample\n,\nint\nnumSamples\n)\ninline\nnoexcept\nClears a specified region of all the channels.\nThis will mark the buffer as cleared if the entire buffer contents are cleared.\nFor speed, this doesn't check whether the channel and sample number are in-range, so be careful!\nThis method will do nothing if the buffer has been marked as cleared (i.e. the hasBeenCleared method returns true.)\nSee also\nhasBeenCleared\n,\nsetNotClear\n◆\nclear()\n[3/3]\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::clear\n(\nint\nchannel\n,\nint\nstartSample\n,\nint\nnumSamples\n)\ninline\nnoexcept\nClears a specified region of just one channel.\nFor speed, this doesn't check whether the channel and sample number are in-range, so be careful!\nThis method will do nothing if the buffer has been marked as cleared (i.e. the hasBeenCleared method returns true.)\nSee also\nhasBeenCleared\n,\nsetNotClear\n◆\nhasBeenCleared()\ntemplate<typename Type>\nbool\njuce::AudioBuffer\n< Type >::hasBeenCleared\n(\n)\nconst\ninline\nnoexcept\nReturns true if the buffer has been entirely cleared.\nNote that this does not actually measure the contents of the buffer - it simply returns a flag that is set when the buffer is cleared, and which is reset whenever functions like getWritePointer are invoked. That means the method is quick, but it may return false negatives when in fact the buffer is still empty.\nReferenced by\njuce::AudioBuffer< float >::makeCopyOf()\n.\n◆\nsetNotClear()\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::setNotClear\n(\n)\ninline\nnoexcept\nForces the internal cleared flag of the buffer to false.\nThis may be useful in the case where you are holding on to a write pointer and call the clear method before writing some data. You can then use this method to mark the buffer as containing data so that subsequent clear calls will succeed. However a better solution is to call getWritePointer each time you need to write data.\n◆\ngetSample()\ntemplate<typename Type>\nType\njuce::AudioBuffer\n< Type >::getSample\n(\nint\nchannel\n,\nint\nsampleIndex\n) const\ninline\nnoexcept\nReturns a sample from the buffer.\nThe channel and index are not checked - they are expected to be in-range. If not, an assertion will be thrown, but in a release build, you're into 'undefined behaviour' territory.\n◆\nsetSample()\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::setSample\n(\nint\ndestChannel\n,\nint\ndestSample\n,\nType\nnewValue\n)\ninline\nnoexcept\nSets a sample in the buffer.\nThe channel and index are not checked - they are expected to be in-range. If not, an assertion will be thrown, but in a release build, you're into 'undefined behaviour' territory.\nThe hasBeenCleared method will return false after this call.\n◆\naddSample()\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::addSample\n(\nint\ndestChannel\n,\nint\ndestSample\n,\nType\nvalueToAdd\n)\ninline\nnoexcept\nAdds a value to a sample in the buffer.\nThe channel and index are not checked - they are expected to be in-range. If not, an assertion will be thrown, but in a release build, you're into 'undefined behaviour' territory.\nThe hasBeenCleared method will return false after this call.\n◆\napplyGain()\n[1/3]\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::applyGain\n(\nint\nchannel\n,\nint\nstartSample\n,\nint\nnumSamples\n,\nType\ngain\n)\ninline\nnoexcept\nApplies a gain multiple to a region of one channel.\nFor speed, this doesn't check whether the channel and sample number are in-range, so be careful!\nReferenced by\njuce::ADSR::applyEnvelopeToBuffer()\n, and\njuce::AudioBuffer< float >::applyGain()\n.\n◆\napplyGain()\n[2/3]\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::applyGain\n(\nint\nstartSample\n,\nint\nnumSamples\n,\nType\ngain\n)\ninline\nnoexcept\nApplies a gain multiple to a region of all the channels.\nFor speed, this doesn't check whether the sample numbers are in-range, so be careful!\n◆\napplyGain()\n[3/3]\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::applyGain\n(\nType\ngain\n)\ninline\nnoexcept\nApplies a gain multiple to all the audio data.\n◆\napplyGainRamp()\n[1/2]\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::applyGainRamp\n(\nint\nchannel\n,\nint\nstartSample\n,\nint\nnumSamples\n,\nType\nstartGain\n,\nType\nendGain\n)\ninline\nnoexcept\nApplies a range of gains to a region of a channel.\nThe gain that is applied to each sample will vary from startGain on the first sample to endGain on the last Sample, so it can be used to do basic fades.\nFor speed, this doesn't check whether the sample numbers are in-range, so be careful!\n◆\napplyGainRamp()\n[2/2]\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::applyGainRamp\n(\nint\nstartSample\n,\nint\nnumSamples\n,\nType\nstartGain\n,\nType\nendGain\n)\ninline\nnoexcept\nApplies a range of gains to a region of all channels.\nThe gain that is applied to each sample will vary from startGain on the first sample to endGain on the last Sample, so it can be used to do basic fades.\nFor speed, this doesn't check whether the sample numbers are in-range, so be careful!\n◆\naddFrom()\n[1/2]\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::addFrom\n(\nint\ndestChannel\n,\nint\ndestStartSample\n,\nconst\nAudioBuffer\n< Type > &\nsource\n,\nint\nsourceChannel\n,\nint\nsourceStartSample\n,\nint\nnumSamples\n,\nType\ngainToApplyToSource\n=\nType\xa0(1)\n)\ninline\nnoexcept\nAdds samples from another buffer to this one.\nThe hasBeenCleared method will return false after this call if samples have been added.\nParameters\ndestChannel\nthe channel within this buffer to add the samples to\ndestStartSample\nthe start sample within this buffer's channel\nsource\nthe source buffer to add from\nsourceChannel\nthe channel within the source buffer to read from\nsourceStartSample\nthe offset within the source buffer's channel to start reading samples from\nnumSamples\nthe number of samples to process\ngainToApplyToSource\nan optional gain to apply to the source samples before they are added to this buffer's samples\nSee also\ncopyFrom\n◆\naddFrom()\n[2/2]\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::addFrom\n(\nint\ndestChannel\n,\nint\ndestStartSample\n,\nconst Type *\nsource\n,\nint\nnumSamples\n,\nType\ngainToApplyToSource\n=\nType\xa0(1)\n)\ninline\nnoexcept\nAdds samples from an array of floats to one of the channels.\nThe hasBeenCleared method will return false after this call if samples have been added.\nParameters\ndestChannel\nthe channel within this buffer to add the samples to\ndestStartSample\nthe start sample within this buffer's channel\nsource\nthe source data to use\nnumSamples\nthe number of samples to process\ngainToApplyToSource\nan optional gain to apply to the source samples before they are added to this buffer's samples\nSee also\ncopyFrom\n◆\naddFromWithRamp()\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::addFromWithRamp\n(\nint\ndestChannel\n,\nint\ndestStartSample\n,\nconst Type *\nsource\n,\nint\nnumSamples\n,\nType\nstartGain\n,\nType\nendGain\n)\ninline\nnoexcept\nAdds samples from an array of floats, applying a gain ramp to them.\nThe hasBeenCleared method will return false after this call if samples have been added.\nParameters\ndestChannel\nthe channel within this buffer to add the samples to\ndestStartSample\nthe start sample within this buffer's channel\nsource\nthe source data to use\nnumSamples\nthe number of samples to process\nstartGain\nthe gain to apply to the first sample (this is multiplied with the source samples before they are added to this buffer)\nendGain\nThe gain that would apply to the sample after the final sample. The gain that applies to the final sample is (numSamples - 1) / numSamples * (endGain - startGain). This ensures a continuous ramp when supplying the same value in endGain and startGain in subsequent blocks. The gain is linearly interpolated between the first and last samples.\n◆\ncopyFrom()\n[1/3]\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::copyFrom\n(\nint\ndestChannel\n,\nint\ndestStartSample\n,\nconst\nAudioBuffer\n< Type > &\nsource\n,\nint\nsourceChannel\n,\nint\nsourceStartSample\n,\nint\nnumSamples\n)\ninline\nnoexcept\nCopies samples from another buffer to this one.\nParameters\ndestChannel\nthe channel within this buffer to copy the samples to\ndestStartSample\nthe start sample within this buffer's channel\nsource\nthe source buffer to read from\nsourceChannel\nthe channel within the source buffer to read from\nsourceStartSample\nthe offset within the source buffer's channel to start reading samples from\nnumSamples\nthe number of samples to process\nSee also\naddFrom\n◆\ncopyFrom()\n[2/3]\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::copyFrom\n(\nint\ndestChannel\n,\nint\ndestStartSample\n,\nconst Type *\nsource\n,\nint\nnumSamples\n)\ninline\nnoexcept\nCopies samples from an array of floats into one of the channels.\nThe hasBeenCleared method will return false after this call if samples have been copied.\nParameters\ndestChannel\nthe channel within this buffer to copy the samples to\ndestStartSample\nthe start sample within this buffer's channel\nsource\nthe source buffer to read from\nnumSamples\nthe number of samples to process\nSee also\naddFrom\n◆\ncopyFrom()\n[3/3]\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::copyFrom\n(\nint\ndestChannel\n,\nint\ndestStartSample\n,\nconst Type *\nsource\n,\nint\nnumSamples\n,\nType\ngain\n)\ninline\nnoexcept\nCopies samples from an array of floats into one of the channels, applying a gain to it.\nThe hasBeenCleared method will return false after this call if samples have been copied.\nParameters\ndestChannel\nthe channel within this buffer to copy the samples to\ndestStartSample\nthe start sample within this buffer's channel\nsource\nthe source buffer to read from\nnumSamples\nthe number of samples to process\ngain\nthe gain to apply\nSee also\naddFrom\n◆\ncopyFromWithRamp()\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::copyFromWithRamp\n(\nint\ndestChannel\n,\nint\ndestStartSample\n,\nconst Type *\nsource\n,\nint\nnumSamples\n,\nType\nstartGain\n,\nType\nendGain\n)\ninline\nnoexcept\nCopies samples from an array of floats into one of the channels, applying a gain ramp.\nThe hasBeenCleared method will return false after this call if samples have been copied.\nParameters\ndestChannel\nthe channel within this buffer to copy the samples to\ndestStartSample\nthe start sample within this buffer's channel\nsource\nthe source buffer to read from\nnumSamples\nthe number of samples to process\nstartGain\nthe gain to apply to the first sample (this is multiplied with the source samples before they are copied to this buffer)\nendGain\nThe gain that would apply to the sample after the final sample. The gain that applies to the final sample is (numSamples - 1) / numSamples * (endGain - startGain). This ensures a continuous ramp when supplying the same value in endGain and startGain in subsequent blocks. The gain is linearly interpolated between the first and last samples.\nSee also\naddFrom\n◆\nfindMinMax()\ntemplate<typename Type>\nRange\n< Type >\njuce::AudioBuffer\n< Type >::findMinMax\n(\nint\nchannel\n,\nint\nstartSample\n,\nint\nnumSamples\n) const\ninline\nnoexcept\nReturns a\nRange\nindicating the lowest and highest sample values in a given section.\nParameters\nchannel\nthe channel to read from\nstartSample\nthe start sample within the channel\nnumSamples\nthe number of samples to check\nReferenced by\njuce::AudioBuffer< float >::getMagnitude()\n.\n◆\ngetMagnitude()\n[1/2]\ntemplate<typename Type>\nType\njuce::AudioBuffer\n< Type >::getMagnitude\n(\nint\nchannel\n,\nint\nstartSample\n,\nint\nnumSamples\n) const\ninline\nnoexcept\nFinds the highest absolute sample value within a region of a channel.\n◆\ngetMagnitude()\n[2/2]\ntemplate<typename Type>\nType\njuce::AudioBuffer\n< Type >::getMagnitude\n(\nint\nstartSample\n,\nint\nnumSamples\n) const\ninline\nnoexcept\nFinds the highest absolute sample value within a region on all channels.\n◆\ngetRMSLevel()\ntemplate<typename Type>\nType\njuce::AudioBuffer\n< Type >::getRMSLevel\n(\nint\nchannel\n,\nint\nstartSample\n,\nint\nnumSamples\n) const\ninline\nnoexcept\nReturns the root mean squared level for a region of a channel.\n◆\nreverse()\n[1/2]\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::reverse\n(\nint\nchannel\n,\nint\nstartSample\n,\nint\nnumSamples\n) const\ninline\nnoexcept\nReverses a part of a channel.\n◆\nreverse()\n[2/2]\ntemplate<typename Type>\nvoid\njuce::AudioBuffer\n< Type >::reverse\n(\nint\nstartSample\n,\nint\nnumSamples\n) const\ninline\nnoexcept\nReverses a part of the buffer." : Content extraction failed for AudioBuffer

----------------------------------------------------------------------
Ran 6 tests in 2.556s

FAILED (failures=1)
Setting up test environment...
Initializing Embedding Model...
CRITICAL WARNING: Could not load 'google/embedding-gemma-300m'. 
Error: google/embedding-gemma-300m is not a local folder and is not a valid model identifier listed on 'https://huggingface.co/models'
If this is a private repository, make sure to pass a token having permission to this repo either by logging in with `hf auth login` or by passing `token=<your_token>`
This model is likely Gated (requires HuggingFace API Token).
Run `huggingface-cli login` or set HF_TOKEN environment variable.
Falling back to 'all-MiniLM-L6-v2' for SYSTEM VERIFICATION.
Initializing ChromaDB...

Test A.1: Connectivity Check

Test A.2: Selector Accuracy
Fetching class list from https://docs.juce.com/master/classes.html...
Found 1120 potential class links.

Test A.3: Content Extraction
Fetching class list from https://docs.juce.com/master/classes.html...
Found 1120 potential class links.

Test B.1: Chunk Token Limit

Test B.2: Overlap Check

Test C: Integration
Fetching class list from https://docs.juce.com/master/classes.html...
Found 1120 potential class links.
Query Results: ['JUCE: juce::AudioProcessorValueTreeState::SliderAttachment Class Reference']
